{"version":3,"sources":["../src/index.js"],"names":["executeFlow","_send","item","send","call","require","default","flow","observer","_guardFlow","dependencies","forEach","_isFunction","k","e","error","stopped","generator","execution","i","nextValue","next","payload","meta","done","value","cachedSteps","steps","isResume","result","_guardNextValue","func","apply","args","_isPromise","throw","type","then","complete","catch","dispose","obj","Error","name","constructor"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\nimport type {Flow, Observer} from './types';\n\n//usage of static 'send' method for better client api'\nlet _send = (item: mixed) => {};\nexport const send = (item: mixed) => _send(item);\n\nexport const call = require('./call').default;\n\nexport function executeFlow(flow: Flow) {\n    return function(observer: Observer) {\n        try {\n            flow = _guardFlow(flow);\n            Object.keys(flow.dependencies).forEach(k => {\n                if (_isFunction(flow.dependencies[k])) {\n                    flow.dependencies[k] = call(flow.dependencies[k])\n                }\n            });\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n\n        let stopped = false;\n        let generator = flow.execution(flow.dependencies);\n\n        let i = 0;\n        let nextValue;\n        _send = item => observer.next({payload: item, meta: {}});\n        (async function() {\n            while (true) {\n                //start the execution by calling generator\n                let {done, value} = generator.next(nextValue);\n                if (done) return;\n\n                //resume execution by using cached steps\n                let cachedSteps = flow.steps[i];\n                if (cachedSteps) {\n                    _send = item => observer.next({payload: item, meta: {isResume: true}});\n                    nextValue = cachedSteps.result;\n                    i++;\n                    continue;\n                }\n\n                //continue execution\n                _send = item => observer.next({payload: item, meta: {}});                \n                value = _guardNextValue(value);\n                try {\n                    nextValue = value.func ? value.func.apply(null, value.args): null;\n                    if (_isPromise(nextValue)) {\n                        nextValue = await nextValue;\n                        _send = item => observer.next({payload: item});\n                    }\n                }\n                catch (e) {\n                    generator.throw(e);\n                }\n\n                flow.steps[i] = {type: value.type, result: nextValue};\n                if (stopped) return;\n                i++;\n            }\n        })()\n        .then(() => observer.complete())\n        .catch(error => observer.error(error));\n\n        return {\n            ...flow,\n            dispose: () => {stopped = true;}\n        }\n    }\n}\n\nfunction _isPromise(obj) {\n    return obj && obj.then;\n}\n\nfunction _guardFlow(flow) {\n    if (!flow)\n        throw new Error(\"flow cannot be null\");\n\n    if (!flow.name)\n        throw new Error(\"flow must have a name\");\n\n    if (!flow.execution)\n        throw new Error(\"flow generator cannot be null\");\n\n    if (!flow.steps)\n        flow.steps = [];\n\n    if (!flow.dependencies)\n        flow.dependencies = {};\n\n\n    return flow;\n}\n\nfunction _guardNextValue(value) {\n    if (!value)\n        throw new Error(\"generator yielded null value. Notice to yieled values must function wrap with 'call' method.\");\n\n    if (value.type != \"call\")\n        throw new Error(\"generator yield value type different than 'call'. type was: \" + value.type + \". Did you wrap your function with 'call' method?\");\n\n    return value;\n}\n\nconst _isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n};"]}