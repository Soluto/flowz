{"version":3,"sources":["../src/index.js"],"names":["executeFlow","_send","item","send","call","require","default","flow","save","complete","observer","_guardFlow","dependencies","forEach","_isFunction","k","e","error","next","stopped","generator","execution","i","nextValue","done","value","_guardNextValue","cachedMethod","steps","result","func","apply","args","_isPromise","throw","type","saveMethod","then","completeMethod","catch","dispose","obj","Error","name","constructor"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\nimport type {Flow, Observer, SaveFlow, CompleteFlow} from './types';\n\n//usage of static 'send' method for better client api'\nlet _send = (item: mixed) => {};\nexport const send = (item: mixed) => _send(item);\n\nexport const call = require('./call').default;\n\nexport function executeFlow(flow: Flow, save?: SaveFlow, complete?: CompleteFlow) {\n    return function(observer: Observer) {\n        try {\n            flow = _guardFlow(flow);\n            Object.keys(flow.dependencies).forEach(k => {\n                if (_isFunction(flow.dependencies[k])) {\n                    flow.dependencies[k] = call(flow.dependencies[k])\n                }\n            });\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n\n        _send = observer.next;\n        let stopped = false;\n        let generator = flow.execution(flow.dependencies);\n        let i = 0;\n        let nextValue;\n        (async function() {\n            while (true) {\n                let {done, value} = generator.next(nextValue);\n                if (done) return;\n                value = _guardNextValue(value);\n\n                let cachedMethod = flow.steps[i];\n                if (cachedMethod) {\n                    nextValue = cachedMethod.result;\n                }\n                else {\n                    try {\n                        nextValue = value.func.apply(null, value.args);\n                        if (_isPromise(nextValue)) {\n                            nextValue = await nextValue;\n                            _send = observer.next;\n                        }\n                    }\n                    catch (e) {\n                        generator.throw(e);\n                    }\n\n                    flow.steps[i] = {type: value.type, result: nextValue};\n\n                    if (save) {\n                        const saveMethod = save(flow);\n                        if (_isPromise(saveMethod)) {\n                            await saveMethod;\n                        }\n                        if (stopped) return;\n                    }\n                }\n                i++;\n            }\n        })()\n        .then(async () => {\n            if (complete) {\n                const completeMethod = complete(flow);\n                if (_isPromise(completeMethod)) {\n                    await completeMethod;\n                }\n            }\n            observer.complete()\n        })\n        .catch(error => observer.error(error));\n\n        return {\n            ...flow,\n            dispose: () => {stopped = true;}\n        }\n    }\n}\n\nfunction _isPromise(obj) {\n    return obj && obj.then;\n}\n\nfunction _guardFlow(flow) {\n    if (!flow)\n        throw new Error(\"flow cannot be null\");\n\n    if (!flow.name)\n        throw new Error(\"flow must have a name\");\n\n    if (!flow.execution)\n        throw new Error(\"flow generator cannot be null\");\n\n    if (!flow.steps)\n        flow.steps = [];\n\n    if (!flow.dependencies)\n        flow.dependencies = {};\n\n\n    return flow;\n}\n\nfunction _guardNextValue(value) {\n    if (!value)\n        throw new Error(\"generator yielded null value. Notice to yieled values must function wrap with 'call' method.\");\n\n    if (value.type != \"call\")\n        throw new Error(\"generator yield value type different than 'call'. type was: \" + value.type + \". Did you wrap your function with 'call' method?\");\n\n    return value;\n}\n\nconst _isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n};\n"]}