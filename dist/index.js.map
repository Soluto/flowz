{"version":3,"sources":["../src/index.js"],"names":["executeFlow","_send","item","send","call","require","default","flow","save","complete","observer","_guardFlow","dependencies","forEach","_isFunction","k","e","error","stopped","generator","execution","steps","length","next","i","nextValue","cachedStep","nextCachedStep","type","result","done","value","_guardNextValue","func","apply","args","_isPromise","throw","saveMethod","then","completeMethod","catch","dispose","obj","Error","name","constructor"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\nimport type {Flow, Observer, SaveFlow, CompleteFlow } from './types';\n\n//usage of static 'send' method for better client api'\nlet _send = (item: mixed) => { };\nexport const send = (item: mixed) => _send(item);\n\nexport const call = require('./call').default;\n\nexport function executeFlow(flow: Flow, save?: SaveFlow, complete?: CompleteFlow) {\n    return function (observer: Observer) {\n        try {\n            flow = _guardFlow(flow);\n            Object.keys(flow.dependencies).forEach(k => {\n                if (_isFunction(flow.dependencies[k])) {\n                    flow.dependencies[k] = call(flow.dependencies[k])\n                }\n            });\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n\n        let stopped = false;\n        let generator = flow.execution(flow.dependencies);\n\n        //set initial _send\n        if (flow.steps.length > 0) {\n            _send = (item: mixed) => { };\n        }\n        else {\n            _send = observer.next;\n        }\n\n        let i = 0;\n        let nextValue;\n        (async function () {\n            while (true) {\n                //resume execution by using cached steps\n                //exepecting 'message' type in the cache is for backwards compatability and will be removed in the next major version\n                const cachedStep = flow.steps[i];\n                const nextCachedStep = flow.steps[i + 1];\n                if (!cachedStep) {\n                    //cache resolving is done\n                }\n                else if (cachedStep.type === \"call\" && !nextCachedStep) {\n                    nextValue = cachedStep.result;\n                    _send = observer.next;                    \n                    generator.next(nextValue);\n                    i++;\n                    continue;\n                }\n                else if (cachedStep.type === \"call\" && nextCachedStep.type === \"call\") {\n                    nextValue = cachedStep.result;\n                    generator.next(nextValue);\n                    i++;\n                    continue;\n                }\n                else if (cachedStep.type === \"call\" && nextCachedStep.type === \"message\") {\n                    nextValue = cachedStep.result;\n                    i++;\n                    continue;\n                }            \n                else if (cachedStep.type === \"message\" && !nextCachedStep) {                    \n                    generator.next(nextValue);\n                    i++;\n                    continue;\n                }                  \n                else if (cachedStep.type === \"message\" && nextCachedStep.type === \"message\") {\n                    i++;\n                    continue;\n                }\n                else if (cachedStep.type === \"message\" && nextCachedStep.type === \"call\") {\n                    generator.next(nextValue);\n                    i++;\n                    continue;\n                }\n\n                //continue execution when cache resolving is completed\n                let {done, value} = generator.next(nextValue);\n                if (done) return;\n                _send = observer.next;\n                value = _guardNextValue(value);\n                try {\n                    nextValue = value.func ? value.func.apply(null, value.args) : null;\n                    if (_isPromise(nextValue)) {\n                        nextValue = await nextValue;\n                        _send = observer.next;\n                    }\n                }\n                catch (e) {\n                    generator.throw(e);\n                }\n\n                flow.steps[i] = { type: value.type, result: nextValue };\n\n                if (save) {\n                    const saveMethod = save(flow);\n                    if (_isPromise(saveMethod)) {\n                        await saveMethod;\n                    }\n                    if (stopped) return;\n                }\n                i++;\n            }\n        })()\n            .then(async () => {\n                if (complete) {\n                    const completeMethod = complete(flow);\n                    if (_isPromise(completeMethod)) {\n                        await completeMethod;\n                    }\n                }\n                observer.complete()\n            })\n            .catch(error => observer.error(error));\n\n        return {\n            ...flow,\n            dispose: () => { stopped = true; }\n        }\n    }\n}\n\nfunction _isPromise(obj) {\n    return obj && obj.then;\n}\n\nfunction _guardFlow(flow) {\n    if (!flow)\n        throw new Error(\"flow cannot be null\");\n\n    if (!flow.name)\n        throw new Error(\"flow must have a name\");\n\n    if (!flow.execution)\n        throw new Error(\"flow generator cannot be null\");\n\n    if (!flow.steps)\n        flow.steps = [];\n\n    if (!flow.dependencies)\n        flow.dependencies = {};\n\n\n    return flow;\n}\n\nfunction _guardNextValue(value) {\n    if (!value)\n        throw new Error(\"generator yielded null value. Notice to yieled values must function wrap with 'call' method.\");\n\n    if (value.type != \"call\")\n        throw new Error(\"generator yield value type different than 'call'. type was: \" + value.type + \". Did you wrap your function with 'call' method?\");\n\n    return value;\n}\n\nconst _isFunction = function (obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n};"]}